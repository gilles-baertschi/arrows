main :: IO () ()
main = arr test >>> print >>> const '\n' >>> putChar

test :: () -> String
test = const ((), (initial, (0, rules))) >>> execMachine >>>[Id] snd >>>[Id] displayMachine

displayMachine :: Machine -> String
displayMachine = fst >>> (double >>> (reverse >>> boolListToString) *** const "[" >>> (<>)) *** (fromRight >>> (double >>> (boolToChar >>> show) *** const "]" >>> (<>)) *** boolListToString>>> (<>)) >>> (<>) 

boolListToString :: List Bool -> String
boolListToString = double >>> first (const boolToChar) >>> map

boolToChar :: Bool -> Char
boolToChar = boolToChoice >>> const '0' ||| const '1'

rules :: List Rule
rules = [(((True, r True), r 1), ((True, r False), r 1)), (((True, r False), r 0), ((False, r False), r 2)), (((True, r True), l ()), ((True, r False), r 3)), (((True, r True), r 3), ((False, r True), r 0))]

initial :: (List Bool, List Bool)
initial = ([], [False])

type Machine = ((List Bool, List Bool), (Int, List Rule))
type Rule = (RulePart, RulePart)
type RulePart = ((Bool, (() | Bool)), (() | Int)) -- ((write, move), (halt | next rule))

execMachine :: State Machine () ()
execMachine = getRulePart >>> (writeAndMove *** continueExec) >>> const ()

getRulePart :: State Machine a RulePart
getRulePart = readAtHead &&& getRule >>>[Id] arr (choice >>> fst ||| snd)

continueExec :: State Machine (() | Int) ()
continueExec = right (setRule >>>[State s] execMachine) >>> const ()

writeAndMove :: State Machine (Bool, (() | Bool)) ()
writeAndMove = writeAtHead *** moveHead >>> const ()

readAtHead :: State Machine a Bool
readAtHead = get >>>[Id] arr[State s] (fst >>> snd >>> head)

writeAtHead :: State Machine Bool ()
writeAtHead = arr double >>>[Id] first get >>>[Id] arr (changeHead >>> fst) >>> put

changeHead :: State Bool Machine Machine
changeHead = first[State s] (second[State s] (arr fromRight >>> first get >>> arr r))

moveHead :: State Machine (() | Bool) ()
moveHead = right (arr boolToChoice >>> moveHeadLeft ||| moveHeadRight) >>> const ()

moveHeadLeft :: State Machine a ()
moveHeadLeft = get >>> first[State s] (arr (first extendIfNeeded >>> moveRight)) >>> put

moveHeadRight :: State Machine a ()
moveHeadRight = get >>> first[State s] (arr (second (fromRight >>> second extendIfNeeded >>> r) >>> moveLeft)) >>> put

extendIfNeeded :: List Bool -> List Bool
extendIfNeeded = (const (r (False, l ()))) ||| r

getRule :: State Machine a Rule
getRule = get >>> arr (snd >>>[Id] (!!))

setRule :: State Machine Int ()
setRule = arr double >>> first get >>> arr (changeRule >>> fst) >>> put

changeRule :: State Int Machine Machine
changeRule = second (first get)
