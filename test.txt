main :: IO () ()
-- main = id
main = arr test >>> (print *** (arr double >>> (const '[' >>> putChar) *** print)) >>> const '\n' >>> putChar

test :: () -> (String, String)
test = const ((), (([], [True]), (0, [(((False, l ()), l ()), ((True, r True), r 0))]))) >>> execMachine >>>[Id] snd >>>[Id] displayMachine

displayMachine :: Machine -> (String, String)
displayMachine = fst >>> (reverse >>> boolListToString) *** boolListToString

boolListToString :: List Bool -> String
boolListToString = double >>> first (const boolToChar) >>> map

boolToChar :: Bool -> Char
boolToChar = boolToChoice >>> const '0' ||| const '1'

rules :: List Rule
rules = [(((True, l ()), l ()), ((True, r True), r 0))]

type Machine = ((List Bool, List Bool), (Int, List Rule))
type Rule = (RulePart, RulePart)
type RulePart = ((Bool, (() | Bool)), (() | Int)) -- ((write, move), (halt | next rule))

execMachine :: State Machine () ()
execMachine = getRulePart >>> (writeAndMove *** continueExec) >>> const ()

getRulePart :: State Machine a RulePart
getRulePart = readAtHead &&& getRule >>> arr (choice >>> fst ||| snd)

continueExec :: State Machine (() | Int) ()
continueExec = right (setRule >>>[State s] execMachine) >>> const ()

writeAndMove :: State Machine (Bool, (() | Bool)) ()
writeAndMove = writeAtHead *** moveHead >>> const ()

readAtHead :: State Machine a Bool
readAtHead = get >>> arr (fst >>> snd >>> head)

writeAtHead :: State Machine Bool ()
writeAtHead = arr double >>>[Id] first get >>>[Id] arr (changeHead >>> fst) >>> put

changeHead :: State Bool Machine Machine
changeHead = first[State s] (second[State s] (arr fromRight >>> first get >>> arr r))

moveHead :: State Machine (() | Bool) ()
moveHead = right (arr boolToChoice >>> moveHeadLeft ||| moveHeadRight) >>> const ()

moveHeadLeft :: State Machine a ()
moveHeadLeft = get >>> first[State s] (arr (first extendIfNeeded >>> moveRight)) >>> put
-- moveHeadLeft = get >>> first[State s] (arr moveRight) >>> put

moveHeadRight :: State Machine a ()
moveHeadRight = get >>> first[State s] (arr (second (fromRight >>> second extendIfNeeded >>> r) >>> moveLeft)) >>> put
-- moveHeadRight = get >>> first[State s] (arr moveLeft) >>> put

extendIfNeeded :: List Bool -> List Bool
extendIfNeeded = (const (r (False, l ()))) ||| r

getRule :: State Machine a Rule
getRule = get >>> arr (snd >>>[Id] (!!))

setRule :: State Machine Int ()
setRule = arr double >>> first get >>> arr (changeRule >>> fst) >>> put

changeRule :: State Int Machine Machine
changeRule = second (first get)
