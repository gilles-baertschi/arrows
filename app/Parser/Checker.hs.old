module Parser.Checker where

import Ast
import Control.Monad
import Control.Monad.State
import Data.Functor
import Data.List
import Parser.Primitives
import Text.Megaparsec

checkAll :: ParserWithState Program ()
checkAll = checkNameSafety >> checkTypeSafety

checkTypeSafety :: ParserWithState Program ()
checkTypeSafety = do
    allDefinitions <- gets definitions
    mapM_ (\(Definition _ referentialType value) -> assertReferentialType referentialType value) allDefinitions
    allDefinitionsFromInstances <- gets (instances)
    mapM_ (\... -> assertReferentialType ... ...) allDefinitionsFromInstances

-- wanted current
assertReferentialType :: ReferentialType -> Value -> ParserWithState Program ()
assertReferentialType (ReferentialType frame references) content =
    -- let (ReferentialType content references') = increaseReferences contentReferentialType $ length references
    void $ runStateT (assertType frame content) references

assertType :: Type -> Value -> ParserWithDoubleState [Type] Program ()
assertType _ (CompilerDefined _) = return ()
assertType (TypeReference index) content = do
    frame <- gets (!! index)
    assertType frame content
assertType frame content@(DefinedValue _ name) = do
    superiorReferentialType <- lift $ definitionType <$> getDefinition name
    superiorType <- addReferentialType superiorReferentialType
    success <- typeGreaterThan superiorType frame
    unless success $ failTypeInference frame content
assertType (AliasReference _ name insertedTypes) content = do
    alias <- lift $ getAlias name
    if name == "Id"
        then case insertedTypes of
            [inputType, outputType] -> assertArrow inputType outputType content
            _ -> undefined
        else do
            let ReferentialType unincreasedMainType otherTypesWithPlaceholders = aliasType alias
            let otherTypesWithoutPlaceholders = drop (length otherTypesWithPlaceholders - length insertedTypes) otherTypesWithPlaceholders
            amount <- gets ((\x -> x - length insertedTypes) . length)
            let (ReferentialType increasedMainType newReferences) = increaseReferences (ReferentialType unincreasedMainType otherTypesWithoutPlaceholders) amount
            gets (++ insertedTypes ++ newReferences) >>= put
            assertType increasedMainType content
-- gets (head . filter (\alias ->) . aliases)
--  case content of
--    (AliasReference _ name' contentTypes) -> do
--        when (name /= name' || length frameTypes /= length contentTypes) $ failTypeInference frame content
--        zipWithM_ assertType frameTypes contentTypes
assertType (InstanceOf _ _) _ = undefined
assertType frame@(Sum x y) content = case content of
    (SumLiteral _ x' y') -> assertType x x' >> assertType y y'
    _ -> failTypeInference frame content
assertType frame@(Product x y) content = case content of
    (ProductLiteral _ x' y') -> assertType x x' >> assertType y y'
    _ -> failTypeInference frame content
assertType frame@Bool content = case content of
    (BoolLiteral _ _) -> return ()
    _ -> failTypeInference frame content
assertType frame@Float content = case content of
    (FloatLiteral _ _) -> return ()
    _ -> failTypeInference frame content
assertType frame@Int content = case content of
    (IntLiteral _ _) -> return ()
    _ -> failTypeInference frame content
assertType frame@Char content = case content of
    (CharLiteral _ _) -> return ()
    _ -> failTypeInference frame content
assertType frame@EmptyTuple content = case content of
    (EmptyTupleLiteral _) -> return ()
    _ -> failTypeInference frame content
assertType (AnyType index) content = case content of
    (BoolLiteral _ _) -> modify (replace index Bool)
    (IntLiteral _ _) -> modify (replace index Int)
    (FloatLiteral _ _) -> modify (replace index Float)
    (EmptyTupleLiteral _) -> modify (replace index EmptyTuple)
    (CharLiteral _ _) -> modify (replace index Char)
    _ -> return ()

assertArrow :: Type -> Type -> Value -> ParserWithDoubleState [Type] Program ()
assertArrow inputType outputType content = case content of
    (ArrowConstant _ value) -> assertType outputType value
    (ArrowComposition _ firstArrow secondArrow) -> do
        sharedType <- addTypeVariabel
        assertType (AliasReference (getOffsetFromValue firstArrow) "Id" [inputType, sharedType]) firstArrow
        assertType (AliasReference (getOffsetFromValue secondArrow) "Id" [sharedType, outputType]) secondArrow
    (ArrowFirst offset innerArrow) -> do
        bypassedType <- addTypeVariabel
        innerInputType <- addTypeVariabel
        innerOutputType <- addTypeVariabel
        successInput <- typeGreaterThan (Product innerInputType bypassedType) inputType
        unless successInput $ failTypeMatch offset (Product innerInputType bypassedType) inputType
        successOutput <- typeGreaterThan (Product innerOutputType bypassedType) outputType
        unless successOutput $ failTypeMatch offset (Product innerOutputType bypassedType) outputType
        assertType (AliasReference (getOffsetFromValue innerArrow) "Id" [innerInputType, innerOutputType]) innerArrow
    -- (ArrowSecond _ arrow) -> return ()
    -- (TripleAsterisks _ firtsArrow secondArrow) -> return ()
    -- (TripleAnd _ firstArrow secondArrow) -> return ()
    -- (ArrowRight _ arrow) -> return ()
    -- (ArrowLeft _ arrow) -> return ()
    -- (TriplePlus _ leftArrow rightArrow) -> return ()
    -- (TripleBar _ leftArrow rightArrow) -> return ()
    _ -> return ()

getAlias :: String -> ParserWithState Program TypeAlias
getAlias name = gets (head . filter ((name ==) . aliasName) . aliases)

getDefinition :: String -> ParserWithState Program Definition
getDefinition name = gets (head . filter ((name ==) . definitionName) . definitions)

addTypeVariabel :: ParserWithDoubleState [Type] Program Type
addTypeVariabel = do
    newIndex <- gets length
    modify (++ [AnyType newIndex])
    return $ TypeReference newIndex

--
{-    data Value
    = ProductLiteral Int Value Value
    | SumLiteral Int Value Value
    | BoolLiteral Int Bool
    | FloatLiteral Int Double
    | IntLiteral Int Int
    | CharLiteral Int Char
    | EmptyTupleLiteral Int
    | DefinedValue Int String
    | ArrowComposition Int Value Value
    | ArrowConstant Int Value
    | ArrowFirst Int Value
    | ArrowSecond Int Value
    | TripleAsterisks Int Value Value
    | TripleAnd Int Value Value
    | ArrowRight Int Value
    | ArrowLeft Int Value
    | TriplePlus Int Value Value
    | TripleBar Int Value Value
    | CompilerDefined Int
    deriving (Read, Eq, Ord, Show)

-}

replace :: Int -> a -> [a] -> [a]
replace i x xs = before ++ [x] ++ after
  where
    (before, rest) = splitAt i xs
    after = case rest of
        [] -> []
        (_ : after') -> after'

failTypeInference :: Type -> Value -> ParserWithDoubleState [Type] Program ()
failTypeInference frame content = do
    setOffset (getOffsetFromValue content)
    fail $ "could not match " ++ show frame ++ " with " ++ show content

failTypeMatch :: ParsingOffset -> Type -> Type -> ParserWithDoubleState [Type] Program ()
failTypeMatch offset superior inferior = do
    setOffset offset
    fail $ "could not match " ++ show superior ++ " with " ++ show inferior

-- tryDereference :: Type -> ParserWithState [Type] Type
-- tryDereference (TypeReference index) = gets (!! index)
-- tryDereference x = return x

-- merge :: ReferentialType -> ReferentialType -> Int -> ReferentialType
-- merge (ReferentialType parent references) child index = ReferentialType parent (references ++ childReferences)
--  where
--    (ReferentialType innerChild childReferences) = increaseReferences child $ length references
--    references' = references !! index

-- typeGreaterThan :: ReferentialType -> ReferentialType -> Maybe String
-- typeGreaterThan (ReferentialType greater referencesGreater) (ReferentialType smaller referencesSmaller) = undefined

typeGreaterThan :: Type -> Type -> ParserWithDoubleState [Type] Program Bool
typeGreaterThan (TypeReference index) smaller = do
    larger <- gets (!! index)
    typeGreaterThan larger smaller
typeGreaterThan larger (TypeReference index) = do
    smaller <- gets (!! index)
    typeGreaterThan larger smaller
typeGreaterThan (AliasReference _ largerName largerArguments) (AliasReference _ smallerName smallerArguments) =
    if largerName == smallerName
        then
            and <$> zipWithM typeGreaterThan largerArguments smallerArguments
        else return False
typeGreaterThan (InstanceOf classesWithOffsets arguments) smaller = do
    let classes = map snd classesWithOffsets
    allInstances <- lift $ gets instances
    let allInstanceAliasNames = nub $ map instanceAliasName allInstances
    let allInstanceAliasNamesWithClasses = map (\name -> (name, map typeClassNameOf $ filter ((== name) . instanceAliasName) allInstances)) allInstanceAliasNames
    let instanceAliasNamesOfClasses = map fst $ filter (\(_, classesOfAlias) -> all (`elem` classesOfAlias) classes) allInstanceAliasNamesWithClasses
    -- aliasesOfClasses <- lift $ mapM getAlias instanceAliasNamesOfClasses
    or <$> mapM (\name -> typeGreaterThan (AliasReference 0 name arguments) smaller) instanceAliasNamesOfClasses
typeGreaterThan larger smaller = return $ larger == smaller

--  = Product Type Type
--    | Sum Type Type
--    | Bool
--    | Float
--    | Int
--    | Char
--    | EmptyTuple
--    | InstanceOf [(Int, String)]
--    | AliasReference Int String [Type]
--    | TypeReference Int

addReferentialType :: ReferentialType -> ParserWithDoubleState [Type] Program Type
addReferentialType referentialType = do
    amount <- gets length
    let (ReferentialType result newReferences) = increaseReferences referentialType amount
    gets (++ newReferences) >>= put
    return result

increaseReferences :: ReferentialType -> Int -> ReferentialType
increaseReferences (ReferentialType t references) index = ReferentialType (increase t) (map increase references)
  where
    increase (Product x y) = Product (increase x) (increase y)
    increase (Sum x y) = Sum (increase x) (increase y)
    increase (AliasReference offset name types) = AliasReference offset name $ map increase types
    increase (TypeReference i) = TypeReference $ i + index
    increase x = x

getOffsetFromValue :: Value -> ParsingOffset
getOffsetFromValue value = case value of
    (ProductLiteral offset _ _) -> offset
    (SumLiteral offset _ _) -> offset
    (BoolLiteral offset _) -> offset
    (FloatLiteral offset _) -> offset
    (IntLiteral offset _) -> offset
    (CharLiteral offset _) -> offset
    (EmptyTupleLiteral offset) -> offset
    (DefinedValue offset _) -> offset
    (ArrowComposition offset _ _) -> offset
    (ArrowConstant offset _) -> offset
    (ArrowFirst offset _) -> offset
    (ArrowSecond offset _) -> offset
    (TripleAsterisks offset _ _) -> offset
    (TripleAnd offset _ _) -> offset
    (ArrowRight offset _) -> offset
    (ArrowLeft offset _) -> offset
    (TriplePlus offset _ _) -> offset
    (TripleBar offset _ _) -> offset
    (CompilerDefined offset) -> offset
