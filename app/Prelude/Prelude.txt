type Id a b = undefined
type IO a b = undefined

type Bool = undefined
type Int = undefined
type Float = undefined
type () = undefined
type Char = undefined

type List a = (() | (a, List a)) 
type String = List Char
type State s a b = (a, s) -> (b, s)

class Arrow y where
    id :: y a a
    arr :: Id a b -> y a b
    (>>>) :: (y a b, y b c) -> y a c
    first :: y a b -> y (a, c) (b, c)
    second :: y a b -> y (c, a) (c, b)
    (***) :: (y a c, y b d) -> y (a, b) (c, d)
    (&&&) :: (y a b, y a c) -> y a (b, c)

-- (Id (a, s) (b, s), Id (a, s) (c, s)) -> Id (a, s) ((b, c), s)

-- first[Id] first >>> second[Id] second >>> (>>>) >>> double >>> first[Id] (const[Id] double >>> arr) >>> (>>>) 
-- (y a b, y a c) -> y a (b, c)

class Arrow y => Choice y where
    left :: y a b -> y (a | c) (b | c)
    right :: y a b -> y (c | a) (c | b)
    (+++) :: (y a c, y b d) -> y (a | b) (c | d)
    (|||) :: (y a c, y b c) -> y (a | b) c

class Arrow y => Apply y where
    app :: y (y a b, a) b

class Eq a where
    (==) :: (a, a) -> Bool
    (/=) :: (a, a) -> Bool

class Eq a => Ord a where
    (>) :: (a, a) -> Bool
    (>=) :: (a, a) -> Bool
    (<) :: (a, a) -> Bool
    (<=) :: (a, a) -> Bool

class Num a where
    (+) :: (a, a) -> a  
    (-) :: (a, a) -> a  
    (*) :: (a, a) -> a
    (/) :: (a, a) -> a
    neg :: a -> a
    abs:: a -> a

class Show a where
    show :: a -> String

instance Arrow Id where
    id = undefined
    arr = undefined
    (>>>) = undefined
    first = undefined
    second = undefined
    (***) = undefined
    (&&&) = undefined

instance Choice Id where
    left = undefined
    right = undefined
    (+++) = undefined
    (|||) = undefined

instance Apply Id where
    app = undefined

instance Arrow IO where
    id = undefined
    arr = undefined
    (>>>) = undefined
    first = undefined
    second = undefined
    (***) = undefined
    (&&&) = undefined

instance Choice IO where
    left = undefined
    right = undefined
    (+++) = undefined
    (|||) = undefined

instance Apply IO where
    app = undefined

instance Arrow (State s) where
    id = id[Id]
    arr = first -- Id a b -> Id (a, s) (b, s)
    (>>>) = (>>>)[Id] -- (Id (a, s) (b, s), Id (b, s) (c, s)) -> Id (a, s) (c, s)
    -- Id (a, s) (b, s) -> Id ((a, c), s) ((b, c), s)
    first = first[Id] >>> double >>> first (const reorderStateFirst) >>> (>>>)[Id] >>> double >>> second (const reorderStateFirst) >>> (>>>)[Id]
    -- Id (a, s) (b, s) -> Id ((c, a), s) ((c, b), s)
    -- second = second[Id] >>> double >>> first (const reorderStateSecond) >>> (>>>)[Id] >>> double >>> second (const reorderStateSecond) >>> (>>>)[Id]
    second = second[Id] >>> double >>> first (const reorderToBack) >>> (>>>)[Id] >>> double >>> second (const reorderToFront) >>> (>>>)[Id]
    -- Id ((a, s) -> (c, s), (b, s) -> (d, s)) (((a, b), s) ((c, d), s))
    (***) = first[State s] *** second[State s] >>> (>>>)[Id]
    (&&&) = (***)[State s] >>> double >>> first (const double >>> arr[State s]) >>> (>>>)[State s] 

instance Choice (State s) where
    -- Id (a, s) (b, s) -> Id ((a | c), s) ((b | c), s)
    left = left[Id] >>> double >>> first (const expandChoiceRight) >>> (>>>)[Id] >>> double >>> second (const constrictChoiceLeft) >>> (>>>)[Id]
    -- y a b -> y (c | a) (c | b)
    right = left[State s] >>> double >>> first (const swapChoice >>> arr) >>> (>>>)[Id] >>> double >>> second (const swapChoice >>> arr) >>> (>>>)[Id]
    -- (y a c, y b d) -> y (a | b) (c | d)
    (+++) = left[State s] *** right[State s] >>> (>>>)[Id]
    -- (y a c, y b c) -> y (a | b) c
    (|||) = (+++)[State s] >>> double >>> second (const resolveChoice >>> arr) >>> (>>>)[Id]

constrictChoiceLeft :: ((a, c) | (b, c)) -> ((a | b), c)
constrictChoiceLeft = first l ||| first r

constrictChoiceRight :: ((c, a) | (c, b)) -> (c, (a | b))
constrictChoiceRight = second l ||| second r

expandChoiceLeft :: (c, (a | b)) -> ((c, a) | (c, b)) 
expandChoiceLeft = undefined

expandChoiceRight :: ((a | b), c) -> ((a, c) | (b, c)) 
expandChoiceRight = undefined

reorderStateFirst :: ((a, b), s) -> ((a, s), b)
reorderStateFirst = swap >>> reorderToFront >>> first[Id] swap

-- reorderStateSecond :: ((a, b), s) -> ((s, a), b)
-- reorderStateSecond = swap >>>[Id] reorderToFront

instance Eq Bool where
    (==) = undefined
    (/=) = (==) >>> not

instance Eq Int where
    (==) = undefined
    (/=) = (==) >>> not

instance Eq Float where
    (==) = undefined
    (/=) = (==) >>> not

instance Eq Char where
    (==) = undefined
    (/=) = (==) >>> not

instance Eq () where
    (==) = const True
    (/=) = const False

instance Ord Int where
   (>) = undefined
   (>=) = undefined
   (<) = undefined
   (<=) = undefined

instance Ord Float where
   (>) = undefined
   (>=) = undefined
   (<) = undefined
   (<=) = undefined

instance Show Bool where
    show = boolToChoice >>> const "False" ||| const "True"

instance Show Char where
    show = double >>> second (const (l ())) >>> r

isZero :: Int -> Bool
isZero = double >>> first (const 0) >>> (==)

hasSignBit :: Int -> Bool
hasSignBit = double >>> first (const 0) >>> (>)

instance Show Int where
    show = double >>> (first isZero) >>> choice >>> (double >>> first hasSignBit >>> choice >>> (mulpipleDigitsToChar >>> reverse) ||| (double >>> first (const (-1)) >>> (*) >>> mulpipleDigitsToChar >>> reverse >>> double >>> first (const '-') >>> r)) ||| (const "0")

mulpipleDigitsToChar :: Int -> String
mulpipleDigitsToChar = double >>> first isZero >>> choice >>> (singleDigitToChar &&& (double >>> second (const 10) >>> (/) >>> mulpipleDigitsToChar) >>> r) ||| const (l ())

singleDigitToChar :: Int -> Char
singleDigitToChar = double >>> second (const 10) >>> (%) >>> double >>> first (const 48) >>> (+) >>> chr

readChar :: IO a Char
readChar = undefined

fst :: (a, b) -> a
fst = undefined

snd :: (a, b) -> b
snd = undefined

swap :: (a, b) -> (b, a)
swap = undefined

swapChoice :: (a | b) -> (b | a)
swapChoice = undefined

reorderToFront :: (a, (b, c)) -> ((a, b), c)
reorderToFront = undefined

reorderToBack :: ((a, b), c) -> (a, (b, c))
reorderToBack = undefined

double :: a -> (a, a)
double = undefined

fromLeft :: (a | b) -> a
fromLeft = id[Id] ||| undefined

fromRight :: (a | b) -> b
fromRight = undefined ||| id[Id]

head :: List a -> a
head = undefined ||| fst

tail :: List a -> List a
tail = undefined ||| snd

instance Num Int where
    (+) = undefined
    (-) = undefined
    (*) = undefined
    (/) = undefined
    neg = undefined
    abs = undefined

instance Num Float where
    (+) = undefined
    (-) = undefined
    (*) = undefined
    (/) = undefined
    neg = undefined
    abs = undefined

(%) :: (Int, Int) -> Int
(%) = undefined

roundToInt :: Float -> Int
roundToInt = undefined

cos :: Float -> Float
cos = undefined

tan :: Float -> Float
tan = undefined

not :: Bool -> Bool
not = undefined

(&&) :: (Bool, Bool) -> Bool
(&&) = undefined

(||) :: (Bool, Bool) -> Bool
(||) = undefined

(&) :: (Int, Int) -> Int
(&) = undefined

(|) :: (Int, Int) -> Int
(|) = undefined

(^) :: (Int, Int) -> Int
(^) = undefined

isLeft :: (a | b) -> Bool
isLeft = const True ||| const[Id] False

isRight :: (a | b) -> Bool
isRight = const False ||| const True

boolToChoice :: Bool -> (() | ())
boolToChoice = double >>> second (const ()) >>> choice

choice :: (Bool, a) -> (a | a)
choice = undefined

resolveChoice :: (a | a) -> a
resolveChoice = id ||| id

l :: a -> (a | b)
l = undefined

r :: a -> (b | a)
r = undefined

chr :: Int -> Char
chr = undefined

ord :: Char -> Int
ord = undefined

put :: State s s ()
put = fst >>>[Id] double >>>[Id] const[State s] ()

get :: State s a s
get = snd >>>[Id] double

putChar :: IO Char ()
putChar = undefined

print :: IO String ()
print = right (putChar *** print) >>> const ()

reverse :: List a -> List a
reverse = double >>> second (const (l ())) >>> moveAllRight >>> snd

moveAllRight :: (List a, List a) -> (List a, List a)
moveAllRight = id[Id] >>> double >>> first (fst >>> isRight) >>> choice >>> (id[Id] ||| (moveRight >>>[Id] moveAllRight))

moveRight :: (List a, List a) -> (List a, List a)
moveRight = first (fromRight >>> swap) >>> reorderToBack >>> second r

moveLeft :: (List a, List a) -> (List a, List a)
moveLeft = second fromRight >>> reorderToFront >>> first (swap >>> r)

(++) :: Int -> Int
(++) = double >>> second (const 1) >>> (+)

(--) :: Int -> Int
(--) = double >>> second (const 1) >>> (-)

(!!) :: (Int, List a) -> a
(!!) = double >>> first (fst >>> isZero) >>> choice >>> ((double >>> second[Id] (const 1) >>> (-)) *** tail >>> (!!)) ||| (snd >>> head)

map :: (a -> b, List a) -> List b
map = expandChoiceLeft >>> snd +++ (double >>> (second fst >>> app) *** (second snd >>> map))
